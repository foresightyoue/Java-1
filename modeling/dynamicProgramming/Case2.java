package modeling.dynamicProgramming;
/*
    给定一个矩阵m，从左上角开始每次只能向右走或者向下走，最后达到右下角的位置，路径中所有数字累加起来就是路径和，
    返回所有路径的最小路径和，如果给定的m如下，那么路径1,3,1,0,6,1,0就是最小路径和，返回12.
    1 3 5 9
    8 1 3 4
    5 0 6 1
    8 8 4 0
    分析：对于这个题目，假设m是m行n列的矩阵，那么我们用dp[m][n]来抽象这个问题，dp[i][j]表示的是从原点到i,j位置的最短路径和
    首先计算第一行和第一列，直接累加即可，那么对于其他位置，要么是从它左边的位置达到，要么是从上边的位置达到，
    我们取左边和上边的较小值，然后加上当前的路径值，就是达到当前点的最短路径。然后从左到右，从上到下依次计算即可。
 */
public class Case2 {
    public static void main(String... agrs) {
        int[][] initData = {{1, 3, 5, 9}, {8, 1, 3, 4}, {5, 0, 6, 1}, {8, 8, 4, 0}};
        int[][] dp = {};
        //todo init dp[i][j] = 0

        /*
            for i,j
            if dp[i][j] == 0 {
                if i==0&&j==0 dp[i][j] = arr[i][j];
                if i==0&&j!=0 dp[i][j] = arr[i][j] + dp[i][j-1];
                if i!=0&&j==0 dp[i][j] = arr[i][j] + dp[i-1][j];
                else
                dp[i][j] = arr[i][j]+min(dp[i-1][j],dp[i][j-1]);
            }
         */
    }
}
